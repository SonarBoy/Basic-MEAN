Create Project:

ng new (Project Name here).

What this does:
+ a new workspace with the (Project Name) as the root
+ initial skeleton app located in the src folder
+ End to End (e2e) test project
+ related config files

Serving up the application:
cd (Project Name)

ng serve --open

+ Starts the dev server and watches the source files
  and rebuilds the app as you make changes to those
  files.

+ The application Shell is the web page which is controlled
  by the AppComponent.


app.component.ts = the component class code
app.component.html = the component template
app.component.css = the components stylesheet

{{}} = Angulars interpolation binding syntax

================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================

To generate new compoenets for your application

ng generate component heros

initial import to make things work in the TS file:
import {Component, OnInit} from '@angular/core';

@Component is a decorator function that specifies the Angular
metadata for the component.

selector - the components CSS element selector
templateUrl - the location of the components template file
styleUrls - the location of the components private CSS styleUrls

ngOnInit() is a lifecycle hook here is where you put initialization
logic

+ To display the HerosComponent you must add it to the template of the Shell
AppComponent
+ remember app-heros is the element selector for the Heros Component
so in app.component.html
we add:

<h1>{{title}}<h1>
<app-heros></app-heros>

we then make the following changes

Create a class called
src/app/hero.ts

export class Hero {
  id: number;
  name: string;
}

we then modify our heroes.component.ts class to reflect the following

import { Component, OnInit } from '@angular/core';
import { Hero } from '../hero';

@Component({
  selector: 'app-heroes',
  templateUrl: './heroes.component.html',
  styleUrls: ['./heroes.component.css']
})
export class HeroesComponent implements OnInit {
  hero: Hero = {
    id: 1,
    name: 'Windstorm'
  };

  constructor() { }

  ngOnInit() {
  }

}

this allows us to display data from our typescript file into the
heros html template file.

Now lets say if we wanted to edit the heros name right in the web page how would we do this?
We would first edit the heros.component.html to look something like this:

<h2>{{hero.name}} Details</h2>
<div><span>id: </span>{{hero.id}}</div>
<div><span>name: </span>{{hero.name}}</div>
<div>
  <label>name:
    <input [(ngModel)]="hero.name" placeholder="name"/>
  </label>
</div>

But note once you run this it would break the application. Why? because we have not imported the forms
module into our main app.module.ts lets do that and see what it looks like.

import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';

//Forms module for inputting data
import {FormsModule} from '@angular/forms';


import { AppComponent } from './app.component';
import { HerosComponent } from './heros/heros.component';

@NgModule({
  declarations: [
    AppComponent,
    HerosComponent
  ],
  imports: [
    BrowserModule,
    //Importing of forms module here
    FormsModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

Note the Commented lines with the // the lines below the comments are the imports to get this two way data binding working.
[(ngModel)] is Angular's two-way data binding syntax.

Here it binds the hero.name property to the HTML textbox so that data can flow in both directions:
from the hero.name property to the textbox, and from the textbox back to the hero.name.


================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================

In this section we will learn how to create a list and edit it.

create a new file in your app folder called mock-heros.ts and populate it with the following:

import {Hero} from './hero';

export const HEROES: Hero[] =[
  { id: 11, name: 'Dr Nice' },
  { id: 12, name: 'Narco' },
  { id: 13, name: 'Bombasto' },
  { id: 14, name: 'Celeritas' },
  { id: 15, name: 'Magneta' },
  { id: 16, name: 'RubberMan' },
  { id: 17, name: 'Dynama' },
  { id: 18, name: 'Dr IQ' },
  { id: 19, name: 'Magma' },
  { id: 20, name: 'Tornado' }
];

We will then change the heros.component.ts to import the list of heros that we just created by the following:

import { Component, OnInit } from '@angular/core';

//Importing the mock heros file NOTE THE NAME USED FOR THE EXPORT MUST BE THE SAME AS THE IMPORT
import { HEROES } from '../mock-heroes';

@Component({
  selector: 'app-heros',
  templateUrl: './heros.component.html',
  styleUrls: ['./heros.component.css']
})
export class HerosComponent implements OnInit {
  //ASSINGMENT OF THE heroes to the exported HEROES file.
  heroes = HEROES;

  constructor() { }

  ngOnInit() {
  }

}

Then in the heros.component.html paste this.

<h2>My Heroes</h2>
<ul class="heroes">
  <li *ngFor="let hero of heroes">
    <span class="badge">{{hero.id}}</span> {{hero.name}}
  </li>
</ul>


NOTE!! THE HEROES COLLECTION THAT YOU CREATED IN THE COMP.TS CLASS is CALLED IN THE HTML CLASS BY THE COLLECTION NAME "heroes"



The *ngFor is Angular's repeater directive. It repeats the host element for each element in a list.

The syntax in this example is as follows:

<li> is the host element.
heroes holds the mock heroes list from the HeroesComponent class, the mock heroes list.
hero holds the current hero object for each iteration through the list.


ADDING A CLICK EVENT!!

First we need to bind the click event to the DOM element like so:
<li *ngFor="let hero of heroes" (click)="onSelect(hero)">

The parentheses around click tell Angular to listen for the <li> element's click event. When the user clicks in the <li>,
Angular executes the onSelect(hero) expression.

We then go do he Heros.component.ts file and change the hero property to selectedHero:
we add the on select method which assigns the clicked hero from the template to the component.
selectedHero: Hero;
onSelect(hero: Hero): void {
  this.selectedHero = hero;
}

we then update the heros.component.HTML  to reflect our click event.
<h2>{{selectedHero.name | uppercase}} Details</h2>
<div><span>id: </span>{{selectedHero.id}}</div>
<div>
  <label>name:
    <input [(ngModel)]="selectedHero.name" placeholder="name"/>
  </label>
</div>

but we ge and error this is because the selected hero is undefined there is no way for the DOM
to know what hero we selected so this breaks everything.

we must wrap all the above html with a div that contains the *ngIf directive and set it to selected hero.

//SEE HOW THIS IS THEN USED TO IDENTIFY THE SELECTED HERO AND ALLOWS US TO USE IT.
<div *ngIf="selectedHero">

  <h2>{{selectedHero.name | uppercase}} Details</h2>
  <div><span>id: </span>{{selectedHero.id}}</div>
  <div>
    <label>name:
      <input [(ngModel)]="selectedHero.name" placeholder="name"/>
    </label>
  </div>

</div>

we can also change some of the styles around when the click happens by ADDING
[class.selected]="hero === selectedHero" to the attributes of the list item.


<li *ngFor="let hero of heroes"
  [class.selected]="hero === selectedHero"
  (click)="onSelect(hero)">

================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================

We will now make a new child component to show the details of the heros.

we start by executing the following command:
ng generate component hero-detail

in the html of this hero detail component we will write the following:
<div *ngIf="hero">

  <h2>{{hero.name | uppercase}} Details</h2>
  <div><span>id: </span>{{hero.id}}</div>
  <div>
    <label>name:
      <input [(ngModel)]="hero.name" placeholder="name"/>
    </label>
  </div>

</div>

In the hero-detail.ts file we will first import the hero class and then we will also inport an Input class from angular core and then
we will go on a bit of a bend

import { Component, OnInit, Input } from '@angular/core';
import { Hero } from '../hero';

we then add the following line to the hero.component.html template
<app-hero-detail [hero]="selectedHero"></app-hero-detail>

we will also add the following line to the exported part of the hero-details component to allow data to be shared from its parent componenet
which is the hero.componenet

export class HeroDetailComponent implements OnInit {
  @Input() hero: Hero;
  constructor() { }

  ngOnInit() {
  }

}




DOCUMENTATION:
@Input() and @Output() allow Angular to share data between the parent context and child directives or components. An @Input()
property is writable while an @Output() property is observable.

Consider this example of a child/parent relationship:

content_copy
<parent-component>
  <child-component></child-component>
</parent-component>
Here, the <child-component> selector, or child directive, is embedded within a <parent-component>, which serves as the child's context.

@Input() and @Output() act as the API, or application programming interface, of the child component in that they allow the
child to communicate with the parent. Think of @Input() and @Output() like ports or doorways—@Input() is the doorway into
the component allowing data to flow in while @Output() is the doorway out of the component, allowing the child component to
send data out.


https://angular.io/guide/template-syntax#inputs-outputs


================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================

CREATING A MOCK SERVICE:

The Tour of Heroes HeroesComponent is currently getting and displaying fake data.

After the refactoring in this tutorial, HeroesComponent will be lean and focused on supporting the view. It will also
be easier to unit-test with a mock service.

first run:

ng generate service hero

this will generate the file hero.service.ts

import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class HeroService {

  constructor() { }
}

NOTE: the @Injectable decorate accepts a metadata object for the service the same way
the @Component() decorator did for your componenet class.

Removing data access from components means you can change your mind about the implementation anytime, without touching any
components. They don't know how the service works.

we then import the hero and add a method to the class to retrieve the heros

import { Injectable } from '@angular/core';

//SEE HERE
import {Hero} from './hero';
import { HEROES } from './mock-heros';


@Injectable({
  providedIn: 'root'
})
export class HeroService {

  constructor() { }

  //SEE HERE
  getHeroes(): Hero[]{
    return HEROES;
  }
}

You must make the HeroService available to the dependency injection system before
Angular can inject it into the HeroesComponent by registering a provider. A provider
is something that can create or deliver a service; in this case, it instantiates the
HeroService class to provide the service.

To make sure that the HeroService can provide this service, register it with the injector,
which is the object that is responsible for choosing and injecting the provider where the app
requires it.

By default, the Angular CLI command ng generate service registers a provider with the root
injector for your service by including provider metadata, that is providedIn: 'root' in the
@Injectable() decorator

When you provide the service at the root level, Angular creates a single, shared instance
of HeroService and injects into any class that asks for it. Registering the provider in the
@Injectable metadata also allows Angular to optimize an app by removing the service if it
turns out not to be used after all.

https://angular.io/api/core/Injectable

Now we have to update the heros.component to make it pull data from our service

First
import {HeroService} from '../hero.service';

replace the definition of the heroes property with a simple declarations
heroes: Hero[];

change the constructor to this
constructor(private heroService: HeroService) { }

it defines a private heroService property and identifies it as a HeroService injection site.

then add the following method:

 //hero retrival done with the getHeros method
  getHeroes():void{
    this.heroes = this.heroService.getHeroes();
  }


you can call this same thing in the constructor but you wanna do it on a needs basis rather than
just upon creation simply because its bad practice and its an unnecessary load.

BIG NOTE

***************************************
This will not work in a real app. You're getting away with it now because the service currently returns
mock heroes. But soon the app will fetch heroes from a remote server, which is an inherently asynchronous
operation.

The HeroService must wait for the server to respond, getHeroes() cannot return immediately with hero data,
and the browser will not block while the service waits.

HeroService.getHeroes() must have an asynchronous signature of some kind.

In this tutorial, HeroService.getHeroes() will return an Observable because it will eventually use the Angular
HttpClient.get method to fetch the heroes and HttpClient.get() returns an Observable.
***************************************


Observable HeroService
Observable is one of the key classes in the RxJS library.

In a later tutorial on HTTP, you'll learn that Angular's HttpClient methods return RxJS Observables. In this
tutorial, you'll simulate getting data from the server with the RxJS of() function.

Open the HeroService file and import the Observable and of symbols from RxJS.

in the hero.service.ts
import { Observable, of } from 'rxjs';

and change the getHeroes() method to the following:
getHeroes(): Observable<Hero[]> {
  return of(HEROES);
}


now since it returns an observables heros value we have to change the getHeros method in the heroes.component.ts to
getHeroes(): void {
  this.heroService.getHeroes()
      .subscribe(heroes => this.heroes = heroes);
}

The previous version assigns an array of heroes to the component's heroes property. The assignment occurs synchronously,
as if the server could return heroes instantly or the browser could freeze the UI while it waited for the server's response.

The new version waits for the Observable to emit the array of heroes—which could happen now or several minutes from now. The subscribe()
method passes the emitted array to the callback, which sets the component's heroes property.

Show Messages

This section guides you through the following:

+ adding a MessagesComponent that displays app messages at the bottom of the screen
+ creating an injectable, app-wide MessageService for sending messages to be displayed
+ injecting MessageService into the HeroService
+ displaying a message when HeroService fetches heroes successfully

ng generate component messages


then add the template tag to the app.component.html root
<app-messages></app-messages>

now we need to create service for these messages
and we populate it as follows:

import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class MessageService {
  messages: string[] = [];

  add(message: string) {
    this.messages.push(message);
  }

  clear() {
    this.messages = [];
  }
}


The service exposes its cache of messages and two methods:
one to add() a message to the cache and another to
clear() the cache.

we then import the Messages service into hero.service.ts

import { MessageService } from './message.service';

Modify the constructor with a parameter that declares a private
messageService property. Angular will inject the singleton
MessageService into that property when it creates the HeroService.

constructor(private messageService: MessageService) { }

we then modify the hero.service.ts to display when the heros are fetched
in the getHeros() method:

getHeroes(): Observable<Hero[]> {
  // TODO: send the message _after_ fetching the heroes
  this.messageService.add('HeroService: fetched heroes');
  return of(HEROES);
}

we then go to the messages.component.ts and import the message service.

import { MessageService } from '../message.service';


we then modify the messages.component.ts's constructor to take in a message sent by
our message service that we created.

constructor(public messageService: MessageService) {}

and finally edit the messages.component.html to reflect the following:

<div *ngIf="messageService.messages.length">

  <h2>Messages</h2>
  <button class="clear"
          (click)="messageService.clear()">clear</button>
  <div *ngFor='let message of messageService.messages'> {{message}} </div>

</div>

================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================

Routing
There are new requirements for the Tour of Heroes app:

Add a Dashboard view.
Add the ability to navigate between the Heroes and Dashboard views.
When users click a hero name in either view, navigate to a detail view of the selected hero.
When users click a deep link in an email, open the detail view for a particular hero.


In angular the best practice is to load and configure the router in a sperate top-level module that is
dedicated to routing and imported by the root AppModule.

Run command to create routing module.
ng generate module app-routing --flat --module=app

--flat puts the file in src/app instead of its own folder
--module=app tells the CLI to register it in the imports array of the app module

Replace the content of the app-routing.module.ts
with the following:

import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { HeroesComponent } from './heroes/heroes.component';

const routes: Routes = [
  { path: 'heroes', component: HeroesComponent }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

First the AppRoutingModule imports the Router Module and Routes so the app can have
routing functionality.

We then import hte Heroes componenet and will give the Rotuer somewhere to go once you configure
the routes.

Routes

The next par of your file is where you configure your Routes.

imports: [ RouterModule.forRoot(routes) ],

the above line adds the RouterModule to the AppRoutingModule import array and
configures it with the routes in one step by calling RouterModule.forRoot();

https://angular.io/api/router/RouterModule

Next we export the Router module so it will be available throughout the app:
exports: [ RouterModule ]

we then add the Routers-outlet to our app.component.html template to work:
<router-outlet></router-outlet>

now you will not see anything come up but the app is being routed if you arr/heroes to the end of the
URL in your browser that you are running you application in you will get to the heroes page.

now we use the ng command to create a custom dashboard componenet:

ng generate component dashboard



The template presents a grid of hero name links.

The *ngFor repeater creates as many links as are in the component's heroes array.
The links are styled as colored blocks by the dashboard.component.css.
The links don't go anywhere yet but they will shortly.
The class is similar to the HeroesComponent class.

It defines a heroes array property.
The constructor expects Angular to inject the HeroService into a private heroService property.
The ngOnInit() lifecycle hook calls getHeroes().

now we still dont have a link to navigate to the dashboard component, the router need an appropriate
route.

add the following lines to the app-routing.module.ts

import { DashboardComponent }   from './dashboard/dashboard.component';
{ path: 'dashboard', component: DashboardComponent },

When the app starts, the browser's address bar points to the web site's root. That doesn't match
any existing route so the router doesn't navigate anywhere. The space below the <router-outlet> is blank.

To make the app navigate to the dashboard automatically, add the following route to the
AppRoutingModule.Routes array.

Navigating to hero details
The HeroDetailsComponent displays details of a selected hero. At the moment the HeroDetailsComponent
is only visible at the bottom of the HeroesComponent

The user should be able to get to these details in three ways.

By clicking a hero in the dashboard.
By clicking a hero in the heroes list.
By pasting a "deep link" URL into the browser address bar that identifies the hero to display.
In this section, you'll enable navigation to the HeroDetailsComponent and liberate it from
the HeroesComponent.

First we import the HeroDetailComponent into the app-routing.module.ts
import { HeroDetailComponent }  from './hero-detail/hero-detail.component';

We then modify the dashboard component to the following:
<a *ngFor="let hero of heroes" class="col-1-4"
    routerLink="/detail/{{hero.id}}">
  <div class="module hero">
    <h4>{{hero.name}}</h4>
  </div>
</a>

Note the new routerLink attribute https://angular.io/api/router/RouterLink


We then alter the heroes.component.html to the following:
<ul class="heroes">
  <li *ngFor="let hero of heroes">
    <a routerLink="/detail/{{hero.id}}">
      <span class="badge">{{hero.id}}</span> {{hero.name}}
    </a>
  </li>
</ul>

note the new <a> tag with the router link to the details of the hero.

Previously the HeroesComponent set the HeroDetailComponent.hero property and
HeroDetailComponent displayed the hero.

HeroesComponent doesn;t do that anymore. Now the router creates the HeroDetail
Component in response to a URL such as ~/detail/11.

the HeroDetailComponent needs a new way to obtain the hero-to-display. This section
explains the following:
- Get the route that created it
- Extract the id from the route
- Accquire the hero with that id from the server via the HeroService.

in the hero-detail.component.ts we will add the follwing lines

import { ActivatedRoute } from '@angular/router';
import { Location } from '@angular/common';
import { HeroService }  from '../hero.service';

constructor(
  private route: ActivatedRoute,
  private heroService: HeroService,
  private location: Location
) {}


The AcivatedRoute holds information about the route to this instance of the HeroDetailComponent.
This component is interested in the route's parameters extracted from the URL.
The "id" parameter is the id of the hero to display.

The HeroService gets hero data from the remote server nad this component will use it to get the
hero-to-display.

The location is an Angular service for interacting with the browser. You'll use it later to navigate
back to the view that navigated here.

We then add to the hero-detail.component the following:

ngOnInit(): void {
  this.getHero();
}

getHero(): void {
  const id = +this.route.snapshot.paramMap.get('id');
  this.heroService.getHero(id)
    .subscribe(hero => this.hero = hero);
}

route.snapshot is a static image of the route information shortly
after the component was created.

the paramMap is a dictionary of route parameter values extracted
from the URL. The "id" key return the id of the hero to fetch.

Route parameters are always strings. the + operator converts the string to a number
which is what a hero id should be.


We then need to open the hero.service.ts and change the getHero method to the following:

getHero(id: number): Observable<Hero> {
  // TODO: send the message _after_ fetching the hero
  this.messageService.add(`HeroService: fetched hero id=${id}`);
  return of(HEROES.find(hero => hero.id === id));
}

Now also add a back button to the hero-detail.component.html

<button (click)="goBack()">go back</button>

add to the hero-detail.component.ts a goBack method:

goBack(): void {
  this.location.back();
}


================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================

HTTP:

In this tutorial, you'll add the following data persistence features
with help from Angular's HttpClient.

The HeroService gets hero data with HTTP requests.
Users can add, edit, and delete heroes and save these changes over HTTP.
Users can search for heroes by name.
When you're done with this page, the app should look like this live example / download example.

Enable Http Service

Http Client is Angular's mechanism for communicating with a remote servie over HTTP

in the app.module.ts import the httpClient:

import{ HttpClientModule } from '@angular/common/http';

we are also going to add the HttpClientModule to the imports

@NgModule({
  imports: [
    HttpClientModule,
  ],
})

we then need to install the In memory Web API Package from npm with the following command:
npm install angular-in-memory-web-api --save

In the API module import the HttpClientInMemoryWebApiModule and the InMemoryDataService
adding that to the app.module.ts file:

import { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api';
import { InMemoryDataService }  from './in-memory-data.service';

and add the following lines to the Imports array

HttpClientModule,

// The HttpClientInMemoryWebApiModule module intercepts HTTP requests
// and returns simulated server responses.
// Remove it when a real server is ready to receive requests.
HttpClientInMemoryWebApiModule.forRoot(
  InMemoryDataService, { dataEncapsulation: false }
)

The forRoot() configuration method takes an InMemoryDataService class that primes the in-memory database.

Generate the class src/app/in-memory-data.service.ts with the following command
ng generate service InMemoryData

in the in-memory-data.service.ts populate the file with the following code:


import { InMemoryDbService } from 'angular-in-memory-web-api';
import { Hero } from './hero';
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class InMemoryDataService implements InMemoryDbService {
  createDb() {
    const heroes = [
      { id: 11, name: 'Dr Nice' },
      { id: 12, name: 'Narco' },
      { id: 13, name: 'Bombasto' },
      { id: 14, name: 'Celeritas' },
      { id: 15, name: 'Magneta' },
      { id: 16, name: 'RubberMan' },
      { id: 17, name: 'Dynama' },
      { id: 18, name: 'Dr IQ' },
      { id: 19, name: 'Magma' },
      { id: 20, name: 'Tornado' }
    ];
    return {heroes};
  }

  // Overrides the genId method to ensure that a hero always has an id.
  // If the heroes array is empty,
  // the method below returns the initial number (11).
  // if the heroes array is not empty, the method below returns the highest
  // hero id + 1.
  genId(heroes: Hero[]): number {
    return heroes.length > 0 ? Math.max(...heroes.map(hero => hero.id)) + 1 : 11;
  }
}

the in-memory-data.service.ts file replaces mock-heroes.ts whcih is now safe to delete.

Heroes and HTTP:

We first Import the HttpClient and HttpHeaders into the hero.service.ts:

import { HttpClient, HttpHeaders } from '@angular/common/http';

then we create a new constructor that again in the hero.service.ts:

constructor(
  private http: HttpClient,
  private messageService: MessageService) { }


Notice that you keep injecting the MessageService but since you'll call it so frequently,
wrap it in a private log() method:

/** Log a HeroService message with the MessageService */
private log(message: string) {
  this.messageService.add(`HeroService: ${message}`);
}

we then define the heroesUrl of the form ":base/:collectionName" with the address of the heroes
resource on the server. Here base is the resource to which requests are made and collectionName
is the heroes data object in hte in-memory-data-service.ts

private heroesUrl = 'api/heroes';

We then will get the heroes with the HttpClient

The current HeroService.getHeroes() uses the RxJS of () function to return an array of mock heroes as an
Observable<Hero[]> so we will now convert it to the following:

getHeroes (): Observable<Hero[]> {
  return this.http.get<Hero[]>(this.heroesUrl)
}

HttpClient.get() returns response data

The HttpClient.get() returns the body of the response as an untyped JSON object by default.
Applying the optional type specifier <Hero[]>, gives you a typed result object.

The server's data API determines the shape of the JSON data. The Tour of Heroes data API returns
the hero data as an array.

Error Handling:

Things go wrong, especially when you're getting data from a remote server. The HeroService.getHeroes()
method should catch errors and do something appropriate.

To catch errors, you "pipe" the observable result from http.get() through an RxJS catchError() operator.

so in the hero.service.ts:

import {catchError, map, tap} from 'rxjs/operators';

we then change the return statement of the getHeroes method to the following:

return this.http.get<Hero[]>(this.heroesUrl)
      .pipe(
        catchError(this.handleError<Hero[]>('getHeroes',[])));

Now we have to go create the handleError() method which would look like this:

/**
 * Handle Http operation that failed.
 * Let the app continue.
 * @param operation - name of the operation that failed
 * @param result - optional value to return as the observable result
 */
private handleError<T> (operation = 'operation', result?: T) {
  return (error: any): Observable<T> => {

    // TODO: send the error to remote logging infrastructure
    console.error(error); // log to console instead

    // TODO: better job of transforming error for user consumption
    this.log(`${operation} failed: ${error.message}`);

    // Let the app keep running by returning an empty result.
    return of(result as T);
  };
}

we then have to tap into the observables:
Tap into the Observable
The HeroService methods will tap into the flow of observable values
and send a message, via the log() method, to the message area at
the bottom of the page.

They'll do that with the RxJS tap() operator, which looks at the
observable values, does something with those values, and passes them
along. The tap() call back doesn't touch the values themselves.

Here is the final version of getHeroes() with the tap()
that logs the operation.

/** GET heroes from the server */
getHeroes (): Observable<Hero[]> {
  return this.http.get<Hero[]>(this.heroesUrl)
    .pipe(
      tap(_ => this.log('fetched heroes')),
      catchError(this.handleError<Hero[]>('getHeroes', []))
    );
}

Get Heroes By ID:

Most web API's support a get by id request in the form :baseURL/:id

Here the base URL is the heroesURL defined in the Heroes and HTTP section
and id is the number of the hero that you want to retrieve for example api/heroes/11.

Update the HeroService getHero() method with the following to make that request:
hero.service.ts


getHero(id: number): Observable<Hero>{
  const url = '${this.heroesUrl}/${id}';

  return this.http.get<Hero>(url).pipe(
    tap(_ => this.log('getched hero id=${id}')),
    catchError(this.handleError<Hero>('getHero id=${id}'))
  );
}

There are threee signigicant differences from getHeroes();
  - getHero() constructs a request URL with the desired hero's id.
  - the server should respond with a single hero rather than an array of heroes.
  - getHero() returns an Observable<Hero>("an observable of Hero objects") rather than an
    observable of the hero arrays.


Update Heroes

Edit a Hero's name in the hero detail view. As you type the hero name updates the headding at
the top of the page. But when you click the go back button the changes are lost.

so we first add the save() command to the hero-detail.component.html:
<button (click)="save()">save</button>

we then create a save function in the hero-detail.component.ts:

save(): void {
   this.heroService.updateHero(this.hero)
     .subscribe(() => this.goBack());
 }

we then need to add the updateHero method to the class of hero-detail.component:

/** PUT: update the hero on the server */
updateHero (hero: Hero): Observable<any> {
  return this.http.put(this.heroesUrl, hero, this.httpOptions).pipe(
    tap(_ => this.log(`updated hero id=${hero.id}`)),
    catchError(this.handleError<any>('updateHero'))
  );
}

the HttpClient.put() method takes three parameters:
-the URL
-the data to update
-httpOptions

the URL is unchanged. The heroes we API knows which hero to update by looking at the hero's id
hte heroes web API expects a special header in HTTP save request. That header is in the httpOptions
constant defined in the HeroService

httpOptions = {
  headers: new HttpHeaders({ 'Content-Type': 'application/json' })
};

We then add the add heros button to the template heroes.component.html
<div>
  <label>Hero name:
    <input #heroName />
  </label>
  <!-- (click) passes input value to add() and then clears the input -->
  <button (click)="add(heroName.value); heroName.value=''">
    add
  </button>
</div>

inresponse to a click event call the components click handler add(), and then clear the input failed
so that its ready for another name Add the following to the HeroesComponenet Class:

add(name: string): void {
  name = name.trim();
  if (!name) { return; }
  this.heroService.addHero({ name } as Hero)
    .subscribe(hero => {
      this.heroes.push(hero);
    });
}

When the given name is non blank the handler creates a Hero like object from the name
and passes it to the services addHero() to hero.service.ts:

/** POST: add a new hero to the server */
addHero (hero: Hero): Observable<Hero> {
  return this.http.post<Hero>(this.heroesUrl, hero, this.httpOptions).pipe(
    tap((newHero: Hero) => this.log(`added hero w/ id=${newHero.id}`)),
    catchError(this.handleError<Hero>('addHero'))
  );
}

add Hero differs from updateHero() in two ways:
- it calls HttpClient.post() instead of put().
- it expects the server to generate an id for the new hero


DELETE a Hero
-each hero in the heroes list should have a delete button.

add the following button element to the HeroesComponent template
<button class="delete" title="delete hero"
  (click)="delete(hero)">x</button>


We then alter the heroes.component.html to reflect the following
<ul class="heroes">
  <li *ngFor="let hero of heroes">
    <a routerLink="/detail/{{hero.id}}">
      <span class="badge">{{hero.id}}</span> {{hero.name}}
    </a>
    <button class="delete" title="delete hero"
      (click)="delete(hero)">x</button>
  </li>
</ul>

we then add the delete method to the heroes.component.ts:
delete(hero: Hero): void {
  this.heroes = this.heroes.filter(h => h !== hero);
  this.heroService.deleteHero(hero).subscribe();
}

and then add the Delete heros method to the hero.service.ts so that it works:

/** DELETE: delete the hero from the server */
deleteHero (hero: Hero | number): Observable<Hero> {
  const id = typeof hero === 'number' ? hero : hero.id;
  const url = `${this.heroesUrl}/${id}`;

  return this.http.delete<Hero>(url, this.httpOptions).pipe(
    tap(_ => this.log(`deleted hero id=${id}`)),
    catchError(this.handleError<Hero>('deleteHero'))
  );
}

Note the following key points:

deleteHero() calls HttpClient.delete().
The URL is the heroes resource URL plus the id of the hero to delete.
You don't send data as you did with put() and post().
You still send the httpOptions.
Refresh the browser and try the new delete functionality.


Search By Name

Here you will add a heroes search feature to the dashboard. As the user types
a name into a search box youll make repeated HTTP requests for heroes filtered by that name
your goal is to issue only as many requests as necessary.

start by adding searchHeroes method to the HeroService:

/* GET heroes whose name contains search term */
searchHeroes(term: string): Observable<Hero[]> {
  if (!term.trim()) {
    // if not search term, return empty hero array.
    return of([]);
  }
  return this.http.get<Hero[]>(`${this.heroesUrl}/?name=${term}`).pipe(
    tap(_ => this.log(`found heroes matching "${term}"`)),
    catchError(this.handleError<Hero[]>('searchHeroes', []))
  );
}

Then open the DashboardComponent template and add the hero search element
to the bottom of the markup:

<h3>Top Heroes</h3>
<div class="grid grid-pad">
  <a *ngFor="let hero of heroes" class="col-1-4"
      routerLink="/detail/{{hero.id}}">
    <div class="module hero">
      <h4>{{hero.name}}</h4>
    </div>
  </a>
</div>

<app-hero-search></app-hero-search>


This template looks a lot like the *ngFor repeater in the HeroesComponent template.

For this to work, the next step is to add a component with a selector
that matches <app-hero-search>.

we then need to create a new componenet called Search component

ng generate component hero-search

In the Hero-search.component.html replace the content with the following:

<div id="search-component">
  <h4><label for="search-box">Hero Search</label></h4>

  <input #searchBox id="search-box" (input)="search(searchBox.value)" />

  <ul class="search-result">
    <li *ngFor="let hero of heroes$ | async" >
      <a routerLink="/detail/{{hero.id}}">
        {{hero.name}}
      </a>
    </li>
  </ul>
</div>


The *ngFor repeats hero objects. Notice that the *ngFor iterates over a list called heroes$,
not heroes. The $ is a convention that indicates heroes$ is an Observable, not an array.

<li *ngFor="let hero of heroes$ | async" >


we then replace the content of hero-search.component.ts with the following:

import { Component, OnInit } from '@angular/core';

import { Observable, Subject } from 'rxjs';

import {
   debounceTime, distinctUntilChanged, switchMap
 } from 'rxjs/operators';

import { Hero } from '../hero';
import { HeroService } from '../hero.service';

@Component({
  selector: 'app-hero-search',
  templateUrl: './hero-search.component.html',
  styleUrls: [ './hero-search.component.css' ]
})
export class HeroSearchComponent implements OnInit {
  heroes$: Observable<Hero[]>;
  private searchTerms = new Subject<string>();

  constructor(private heroService: HeroService) {}

  // Push a search term into the observable stream.
  search(term: string): void {
    this.searchTerms.next(term);
  }

  ngOnInit(): void {
    this.heroes$ = this.searchTerms.pipe(
      // wait 300ms after each keystroke before considering the term
      debounceTime(300),

      // ignore new term if same as previous term
      distinctUntilChanged(),

      // switch to new search observable each time the term changes
      switchMap((term: string) => this.heroService.searchHeroes(term)),
    );
  }
}

A Subject is both a source of observable values and an Observable itself. You can subscribe to a
Subject as you would any Observable.

You can also push values into that Observable by calling its next(value) method as the search() method does.

The event binding to the textbox's input event calls the search() method.

Chaining RxJS operators
Passing a new search term directly to the searchHeroes() after every user keystroke would create an excessive
amount of HTTP requests, taxing server resources and burning through data plans.

Instead, the ngOnInit() method pipes the searchTerms observable through a sequence of RxJS operators that reduce
the number of calls to the searchHeroes(), ultimately returning an observable of timely hero
search results (each a Hero[]).

