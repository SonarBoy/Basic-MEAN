Create Project:

ng new (Project Name here).

What this does:
+ a new workspace with the (Project Name) as the root
+ initial skeleton app located in the src folder
+ End to End (e2e) test project
+ related config files

Serving up the application:
cd (Project Name)

ng serve --open

+ Starts the dev server and watches the source files
  and rebuilds the app as you make changes to those
  files.

+ The application Shell is the web page which is controlled
  by the AppComponent.


app.component.ts = the component class code
app.component.html = the component template
app.component.css = the components stylesheet

{{}} = Angulars interpolation binding syntax

================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================

To generate new compoenets for your application

ng generate component heros

initial import to make things work in the TS file:
import {Component, OnInit} from '@angular/core';

@Component is a decorator function that specifies the Angular
metadata for the component.

selector - the components CSS element selector
templateUrl - the location of the components template file
styleUrls - the location of the components private CSS styleUrls

ngOnInit() is a lifecycle hook here is where you put initialization
logic

+ To display the HerosComponent you must add it to the template of the Shell
AppComponent
+ remember app-heros is the element selector for the Heros Component
so in app.component.html
we add:

<h1>{{title}}<h1>
<app-heros></app-heros>

we then make the following changes

Create a class called
src/app/hero.ts

export class Hero {
  id: number;
  name: string;
}

we then modify our heroes.component.ts class to reflect the following

import { Component, OnInit } from '@angular/core';
import { Hero } from '../hero';

@Component({
  selector: 'app-heroes',
  templateUrl: './heroes.component.html',
  styleUrls: ['./heroes.component.css']
})
export class HeroesComponent implements OnInit {
  hero: Hero = {
    id: 1,
    name: 'Windstorm'
  };

  constructor() { }

  ngOnInit() {
  }

}

this allows us to display data from our typescript file into the
heros html template file.

Now lets say if we wanted to edit the heros name right in the web page how would we do this?
We would first edit the heros.component.html to look something like this:

<h2>{{hero.name}} Details</h2>
<div><span>id: </span>{{hero.id}}</div>
<div><span>name: </span>{{hero.name}}</div>
<div>
  <label>name:
    <input [(ngModel)]="hero.name" placeholder="name"/>
  </label>
</div>

But note once you run this it would break the application. Why? because we have not imported the forms
module into our main app.module.ts lets do that and see what it looks like.

import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';

//Forms module for inputting data
import {FormsModule} from '@angular/forms';


import { AppComponent } from './app.component';
import { HerosComponent } from './heros/heros.component';

@NgModule({
  declarations: [
    AppComponent,
    HerosComponent
  ],
  imports: [
    BrowserModule,
    //Importing of forms module here
    FormsModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

Note the Commented lines with the // the lines below the comments are the imports to get this two way data binding working.
[(ngModel)] is Angular's two-way data binding syntax.

Here it binds the hero.name property to the HTML textbox so that data can flow in both directions:
from the hero.name property to the textbox, and from the textbox back to the hero.name.


================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================

In this section we will learn how to create a list and edit it.

create a new file in your app folder called mock-heros.ts and populate it with the following:

import {Hero} from './hero';

export const HEROES: Hero[] =[
  { id: 11, name: 'Dr Nice' },
  { id: 12, name: 'Narco' },
  { id: 13, name: 'Bombasto' },
  { id: 14, name: 'Celeritas' },
  { id: 15, name: 'Magneta' },
  { id: 16, name: 'RubberMan' },
  { id: 17, name: 'Dynama' },
  { id: 18, name: 'Dr IQ' },
  { id: 19, name: 'Magma' },
  { id: 20, name: 'Tornado' }
];

We will then change the heros.component.ts to import the list of heros that we just created by the following:

import { Component, OnInit } from '@angular/core';

//Importing the mock heros file NOTE THE NAME USED FOR THE EXPORT MUST BE THE SAME AS THE IMPORT
import { HEROES } from '../mock-heroes';

@Component({
  selector: 'app-heros',
  templateUrl: './heros.component.html',
  styleUrls: ['./heros.component.css']
})
export class HerosComponent implements OnInit {
  //ASSINGMENT OF THE heroes to the exported HEROES file.
  heroes = HEROES;

  constructor() { }

  ngOnInit() {
  }

}

Then in the heros.component.html paste this.

<h2>My Heroes</h2>
<ul class="heroes">
  <li *ngFor="let hero of heroes">
    <span class="badge">{{hero.id}}</span> {{hero.name}}
  </li>
</ul>


NOTE!! THE HEROES COLLECTION THAT YOU CREATED IN THE COMP.TS CLASS is CALLED IN THE HTML CLASS BY THE COLLECTION NAME "heroes"



The *ngFor is Angular's repeater directive. It repeats the host element for each element in a list.

The syntax in this example is as follows:

<li> is the host element.
heroes holds the mock heroes list from the HeroesComponent class, the mock heroes list.
hero holds the current hero object for each iteration through the list.


ADDING A CLICK EVENT!!

First we need to bind the click event to the DOM element like so:
<li *ngFor="let hero of heroes" (click)="onSelect(hero)">

The parentheses around click tell Angular to listen for the <li> element's click event. When the user clicks in the <li>,
Angular executes the onSelect(hero) expression.

We then go do he Heros.component.ts file and change the hero property to selectedHero:
we add the on select method which assigns the clicked hero from the template to the component.
selectedHero: Hero;
onSelect(hero: Hero): void {
  this.selectedHero = hero;
}

we then update the heros.component.HTML  to reflect our click event.
<h2>{{selectedHero.name | uppercase}} Details</h2>
<div><span>id: </span>{{selectedHero.id}}</div>
<div>
  <label>name:
    <input [(ngModel)]="selectedHero.name" placeholder="name"/>
  </label>
</div>

but we ge and error this is because the selected hero is undefined there is no way for the DOM
to know what hero we selected so this breaks everything.

we must wrap all the above html with a div that contains the *ngIf directive and set it to selected hero.

//SEE HOW THIS IS THEN USED TO IDENTIFY THE SELECTED HERO AND ALLOWS US TO USE IT.
<div *ngIf="selectedHero">

  <h2>{{selectedHero.name | uppercase}} Details</h2>
  <div><span>id: </span>{{selectedHero.id}}</div>
  <div>
    <label>name:
      <input [(ngModel)]="selectedHero.name" placeholder="name"/>
    </label>
  </div>

</div>

we can also change some of the styles around when the click happens by ADDING
[class.selected]="hero === selectedHero" to the attributes of the list item.


<li *ngFor="let hero of heroes"
  [class.selected]="hero === selectedHero"
  (click)="onSelect(hero)">

================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================

We will now make a new child component to show the details of the heros.

we start by executing the following command:
ng generate component hero-detail

in the html of this hero detail component we will write the following:
<div *ngIf="hero">

  <h2>{{hero.name | uppercase}} Details</h2>
  <div><span>id: </span>{{hero.id}}</div>
  <div>
    <label>name:
      <input [(ngModel)]="hero.name" placeholder="name"/>
    </label>
  </div>

</div>

In the hero-detail.ts file we will first import the hero class and then we will also inport an Input class from angular core and then
we will go on a bit of a bend

import { Component, OnInit, Input } from '@angular/core';
import { Hero } from '../hero';

we then add the following line to the hero.component.html template
<app-hero-detail [hero]="selectedHero"></app-hero-detail>

we will also add the following line to the exported part of the hero-details component to allow data to be shared from its parent componenet
which is the hero.componenet

export class HeroDetailComponent implements OnInit {
  @Input() hero: Hero;
  constructor() { }

  ngOnInit() {
  }

}




DOCUMENTATION:
@Input() and @Output() allow Angular to share data between the parent context and child directives or components. An @Input()
property is writable while an @Output() property is observable.

Consider this example of a child/parent relationship:

content_copy
<parent-component>
  <child-component></child-component>
</parent-component>
Here, the <child-component> selector, or child directive, is embedded within a <parent-component>, which serves as the child's context.

@Input() and @Output() act as the API, or application programming interface, of the child component in that they allow the
child to communicate with the parent. Think of @Input() and @Output() like ports or doorways—@Input() is the doorway into
the component allowing data to flow in while @Output() is the doorway out of the component, allowing the child component to
send data out.


https://angular.io/guide/template-syntax#inputs-outputs


================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================

CREATING A MOCK SERVICE:

The Tour of Heroes HeroesComponent is currently getting and displaying fake data.

After the refactoring in this tutorial, HeroesComponent will be lean and focused on supporting the view. It will also
be easier to unit-test with a mock service.

first run:

ng generate service hero

this will generate the file hero.service.ts

import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class HeroService {

  constructor() { }
}

NOTE: the @Injectable decorate accepts a metadata object for the service the same way
the @Component() decorator did for your componenet class.

Removing data access from components means you can change your mind about the implementation anytime, without touching any
components. They don't know how the service works.

we then import the hero and add a method to the class to retrieve the heros

import { Injectable } from '@angular/core';

//SEE HERE
import {Hero} from './hero';
import { HEROES } from './mock-heros';


@Injectable({
  providedIn: 'root'
})
export class HeroService {

  constructor() { }

  //SEE HERE
  getHeroes(): Hero[]{
    return HEROES;
  }
}

You must make the HeroService available to the dependency injection system before
Angular can inject it into the HeroesComponent by registering a provider. A provider
is something that can create or deliver a service; in this case, it instantiates the
HeroService class to provide the service.

To make sure that the HeroService can provide this service, register it with the injector,
which is the object that is responsible for choosing and injecting the provider where the app
requires it.

By default, the Angular CLI command ng generate service registers a provider with the root
injector for your service by including provider metadata, that is providedIn: 'root' in the
@Injectable() decorator

When you provide the service at the root level, Angular creates a single, shared instance
of HeroService and injects into any class that asks for it. Registering the provider in the
@Injectable metadata also allows Angular to optimize an app by removing the service if it
turns out not to be used after all.

https://angular.io/api/core/Injectable

Now we have to update the heros.component to make it pull data from our service

First
import {HeroService} from '../hero.service';

replace the definition of the heroes property with a simple declarations
heroes: Hero[];

change the constructor to this
constructor(private heroService: HeroService) { }

it defines a private heroService property and identifies it as a HeroService injection site.

then add the following method:

 //hero retrival done with the getHeros method
  getHeroes():void{
    this.heroes = this.heroService.getHeroes();
  }


you can call this same thing in the constructor but you wanna do it on a needs basis rather than
just upon creation simply because its bad practice and its an unnecessary load.

BIG NOTE

***************************************
This will not work in a real app. You're getting away with it now because the service currently returns
mock heroes. But soon the app will fetch heroes from a remote server, which is an inherently asynchronous
operation.

The HeroService must wait for the server to respond, getHeroes() cannot return immediately with hero data,
and the browser will not block while the service waits.

HeroService.getHeroes() must have an asynchronous signature of some kind.

In this tutorial, HeroService.getHeroes() will return an Observable because it will eventually use the Angular
HttpClient.get method to fetch the heroes and HttpClient.get() returns an Observable.
***************************************


Observable HeroService
Observable is one of the key classes in the RxJS library.

In a later tutorial on HTTP, you'll learn that Angular's HttpClient methods return RxJS Observables. In this
tutorial, you'll simulate getting data from the server with the RxJS of() function.

Open the HeroService file and import the Observable and of symbols from RxJS.

in the hero.service.ts
import { Observable, of } from 'rxjs';

and change the getHeroes() method to the following:
getHeroes(): Observable<Hero[]> {
  return of(HEROES);
}


now since it returns an observables heros value we have to change the getHeros method in the heroes.component.ts to
getHeroes(): void {
  this.heroService.getHeroes()
      .subscribe(heroes => this.heroes = heroes);
}

The previous version assigns an array of heroes to the component's heroes property. The assignment occurs synchronously,
as if the server could return heroes instantly or the browser could freeze the UI while it waited for the server's response.

The new version waits for the Observable to emit the array of heroes—which could happen now or several minutes from now. The subscribe()
method passes the emitted array to the callback, which sets the component's heroes property.

Show Messages

This section guides you through the following:

+ adding a MessagesComponent that displays app messages at the bottom of the screen
+ creating an injectable, app-wide MessageService for sending messages to be displayed
+ injecting MessageService into the HeroService
+ displaying a message when HeroService fetches heroes successfully

ng generate component messages


then add the template tag to the app.component.html root
<app-messages></app-messages>

now we need to create service for these messages
and we populate it as follows:

import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class MessageService {
  messages: string[] = [];

  add(message: string) {
    this.messages.push(message);
  }

  clear() {
    this.messages = [];
  }
}


The service exposes its cache of messages and two methods:
one to add() a message to the cache and another to
clear() the cache.

we then import the Messages service into hero.service.ts

import { MessageService } from './message.service';

Modify the constructor with a parameter that declares a private
messageService property. Angular will inject the singleton
MessageService into that property when it creates the HeroService.

constructor(private messageService: MessageService) { }

we then modify the hero.service.ts to display when the heros are fetched
in the getHeros() method:

getHeroes(): Observable<Hero[]> {
  // TODO: send the message _after_ fetching the heroes
  this.messageService.add('HeroService: fetched heroes');
  return of(HEROES);
}

we then go to the messages.component.ts and import the message service.

import { MessageService } from '../message.service';


we then modify the messages.component.ts's constructor to take in a message sent by
our message service that we created.

constructor(public messageService: MessageService) {}

and finally edit the messages.component.html to reflect the following:

<div *ngIf="messageService.messages.length">

  <h2>Messages</h2>
  <button class="clear"
          (click)="messageService.clear()">clear</button>
  <div *ngFor='let message of messageService.messages'> {{message}} </div>

</div>

================================================================================================================================
================================================================================================================================
================================================================================================================================
================================================================================================================================

Routing
There are new requirements for the Tour of Heroes app:

Add a Dashboard view.
Add the ability to navigate between the Heroes and Dashboard views.
When users click a hero name in either view, navigate to a detail view of the selected hero.
When users click a deep link in an email, open the detail view for a particular hero.


In angular the best practice is to load and configure the router in a sperate top-level module that is
dedicated to routing and imported by the root AppModule.

Run command to create routing module.
ng generate module app-routing --flat --module=app

--flat puts the file in src/app instead of its own folder
--module=app tells the CLI to register it in the imports array of the app module

Replace the content of the app-routing.module.ts
with the following:

import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { HeroesComponent } from './heroes/heroes.component';

const routes: Routes = [
  { path: 'heroes', component: HeroesComponent }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

First the AppRoutingModule imports the Router Module and Routes so the app can have
routing functionality.

We then import hte Heroes componenet and will give the Rotuer somewhere to go once you configure
the routes.

Routes

The next par of your file is where you configure your Routes.

imports: [ RouterModule.forRoot(routes) ],

the above line adds the RouterModule to the AppRoutingModule import array and
configures it with the routes in one step by calling RouterModule.forRoot();

https://angular.io/api/router/RouterModule

Next we export the Router module so it will be available throughout the app:
exports: [ RouterModule ]

we then add the Routers-outlet to our app.component.html template to work:
<router-outlet></router-outlet>

now you will not see anything come up but the app is being routed if you arr/heroes to the end of the
URL in your browser that you are running you application in you will get to the heroes page.

now we use the ng command to create a custom dashboard componenet:

ng generate component dashboard



The template presents a grid of hero name links.

The *ngFor repeater creates as many links as are in the component's heroes array.
The links are styled as colored blocks by the dashboard.component.css.
The links don't go anywhere yet but they will shortly.
The class is similar to the HeroesComponent class.

It defines a heroes array property.
The constructor expects Angular to inject the HeroService into a private heroService property.
The ngOnInit() lifecycle hook calls getHeroes().

now we still dont have a link to navigate to the dashboard component, the router need an appropriate
route.

add the following lines to the app-routing.module.ts

import { DashboardComponent }   from './dashboard/dashboard.component';
{ path: 'dashboard', component: DashboardComponent },

When the app starts, the browser's address bar points to the web site's root. That doesn't match
any existing route so the router doesn't navigate anywhere. The space below the <router-outlet> is blank.

To make the app navigate to the dashboard automatically, add the following route to the
AppRoutingModule.Routes array.




